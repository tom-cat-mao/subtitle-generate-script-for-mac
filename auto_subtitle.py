#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys
import os
import subprocess
import shutil
from pathlib import Path
from datetime import timedelta
import time

# å°è¯•å¯¼å…¥ lightning-whisper-mlx
try:
    from lightning_whisper_mlx import LightningWhisperMLX
except ImportError:
    print("âŒ Critical Error: 'lightning-whisper-mlx' not found.")
    sys.exit(1)

# ================= å¸¸é‡å®šä¹‰ =================
HOP_LENGTH = 160
SAMPLE_RATE = 16000
SUPPORTED_EXTS = {'.mp4', '.mkv', '.mov', '.avi', '.webm', '.flv', '.wmv', '.m4v', '.ts'}

# ASS é»˜è®¤å¤´éƒ¨ä¿¡æ¯
ASS_HEADER = """[Script Info]
Title: Generated by Lightning-Whisper-MLX
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

# ================= æ ¸å¿ƒå·¥å…·å‡½æ•° =================

def check_dependencies():
    if not shutil.which("ffmpeg"):
        print("âŒ Error: 'ffmpeg' command not found. Install via: brew install ffmpeg")
        sys.exit(1)

def frames_to_seconds(frames):
    return frames * HOP_LENGTH / SAMPLE_RATE

def format_timestamp_srt(seconds):
    """SRT æ ¼å¼: 00:00:00,000"""
    td = timedelta(seconds=seconds)
    total_seconds = int(td.total_seconds())
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    secs = total_seconds % 60
    millis = int(td.microseconds / 1000)
    return f"{hours:02}:{minutes:02}:{secs:02},{millis:03}"

def format_timestamp_vtt(seconds):
    """VTT æ ¼å¼: 00:00:00.000 (ä¸ SRT ä»…åˆ†éš”ç¬¦ä¸åŒ)"""
    return format_timestamp_srt(seconds).replace(',', '.')

def format_timestamp_ass(seconds):
    """ASS æ ¼å¼: H:MM:SS.cs (ç™¾åˆ†ç§’, ä¿ç•™2ä½å°æ•°)"""
    td = timedelta(seconds=seconds)
    total_seconds = int(td.total_seconds())
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    secs = total_seconds % 60
    # ASS éœ€è¦ç™¾åˆ†ç§’ (centiseconds)
    cs = int(td.microseconds / 10000) 
    return f"{hours}:{minutes:02}:{secs:02}.{cs:02}"

def extract_audio(video_path: Path, output_wav_path: Path):
    """FFmpeg æå–éŸ³é¢‘"""
    print(f"ğŸ”¨ Extracting audio to {output_wav_path.name}...")
    cmd = [
        "ffmpeg", "-y", "-i", str(video_path),
        "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
        "-loglevel", "error", str(output_wav_path)
    ]
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError:
        print(f"âŒ FFmpeg failed to extract audio.")
        sys.exit(1)

# ================= æ ¼å¼å†™å…¥å™¨ =================

def write_srt(segments, output_path):
    with open(output_path, "w", encoding="utf-8") as f:
        for i, seg in enumerate(segments):
            start = format_timestamp_srt(frames_to_seconds(seg[0]))
            end = format_timestamp_srt(frames_to_seconds(seg[1]))
            text = seg[2].strip()
            f.write(f"{i+1}\n{start} --> {end}\n{text}\n\n")

def write_vtt(segments, output_path):
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("WEBVTT\n\n")
        for seg in segments:
            start = format_timestamp_vtt(frames_to_seconds(seg[0]))
            end = format_timestamp_vtt(frames_to_seconds(seg[1]))
            text = seg[2].strip()
            f.write(f"{start} --> {end}\n{text}\n\n")

def write_ass(segments, output_path):
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(ASS_HEADER)
        for seg in segments:
            start = format_timestamp_ass(frames_to_seconds(seg[0]))
            end = format_timestamp_ass(frames_to_seconds(seg[1]))
            text = seg[2].strip().replace('\n', '\\N') # å¤„ç†æ¢è¡Œç¬¦
            # Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text
            f.write(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{text}\n")

def write_txt(segments, output_path):
    with open(output_path, "w", encoding="utf-8") as f:
        for seg in segments:
            f.write(f"{seg[2].strip()}\n")

# ================= ä¸»æµç¨‹ =================

def process_file(args):
    video_file = Path(args.video_path)
    if not video_file.exists():
        print(f"âŒ File not found: {video_file}")
        sys.exit(1)

    # éŸ³é¢‘æå–è·¯å¾„
    if video_file.suffix.lower() == '.wav':
        temp_audio_path = video_file
        should_delete_audio = False
    else:
        temp_audio_path = video_file.with_name(f"{video_file.stem}_temp_lwm.wav")
        extract_audio(video_file, temp_audio_path)
        should_delete_audio = not args.keep_audio

    # æ¨¡å‹åˆå§‹åŒ–
    print(f"ğŸš€ Initializing Model: {args.model} (Quant: {args.quant})...")
    try:
        whisper = LightningWhisperMLX(model=args.model, batch_size=args.batch_size, quant=args.quant)
    except Exception as e:
        print(f"âŒ Model Init Failed: {e}. Check load_models.py.")
        if should_delete_audio: os.remove(temp_audio_path)
        sys.exit(1)

    # è½¬å½•
    print(f"ğŸ™ï¸ Transcribing...")
    try:
        result = whisper.transcribe(audio_path=str(temp_audio_path))
    except Exception as e:
        print(f"âŒ Transcription Failed: {e}")
        if should_delete_audio: os.remove(temp_audio_path)
        sys.exit(1)

    # ç»“æœç”Ÿæˆ
    if 'segments' in result and result['segments']:
        segments = result['segments']
        base_name = video_file.with_suffix('')
        
        formats = args.format.split(',')
        if 'all' in formats:
            formats = ['srt', 'ass', 'vtt', 'txt']

        for fmt in formats:
            fmt = fmt.strip().lower()
            out_path = base_name.with_suffix(f".{fmt}")
            print(f"ğŸ’¾ Saving {fmt.upper()}: {out_path.name}")
            
            if fmt == 'srt':
                write_srt(segments, out_path)
            elif fmt == 'ass':
                write_ass(segments, out_path)
            elif fmt == 'vtt':
                write_vtt(segments, out_path)
            elif fmt == 'txt':
                write_txt(segments, out_path)
        
        print(f"âœ… Success!")
    else:
        print("âš ï¸ No speech detected.")

    # æ¸…ç†
    if should_delete_audio and temp_audio_path.exists():
        os.remove(temp_audio_path)

def main():
    parser = argparse.ArgumentParser(description="Lightning-Whisper-MLX Subtitle Generator")
    parser.add_argument("video_path", type=str, help="Input video file")
    parser.add_argument("--model", type=str, default="medium", help="Model: tiny, base, small, medium, large-v3")
    parser.add_argument("--quant", type=str, choices=["4bit", "8bit"], default=None, help="Quantization")
    parser.add_argument("--batch_size", type=int, default=12)
    parser.add_argument("--format", type=str, default="srt", help="Output format: srt, ass, vtt, txt, or all (comma separated)")
    parser.add_argument("--keep_audio", action="store_true", help="Keep temporary WAV file")

    args = parser.parse_args()
    check_dependencies()
    process_file(args)

if __name__ == "__main__":
    main()
